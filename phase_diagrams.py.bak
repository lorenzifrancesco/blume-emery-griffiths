# -*- coding: utf-8 -*-
"""HW1_plot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kruBiiWTGhLCYzhrKc18w39pq7eii685
"""

import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import fsolve
from tqdm import tqdm
import os.path
from mpl_toolkits.mplot3d import Axes3D
import threading
# WARN: since Colab cannot find the LaTeX library, in the plot preparation phase
# it is better to have the script in local and uncomment the following lines for
# have LaTeX fonts
#
# plt.rcParams.update({
#     "text.usetex": True,
# })
#
# reproduce figures with the (T/j, x) plane and different K
# bSomething means \beta * Something
#
# solve (3.10) always valid in the assumption M!=0

print("\n============= defining functions =============\n")
def get_arrays(N=200):
  tj_vec = np.linspace(0.0001, 0.9999, N) # T/J
  x_vec  = np.linspace(0.0001, 0.9999, N)
  return [tj_vec, x_vec] 

def get_arrays_order(N=200):
  tj_vec = np.linspace(0.0001, 0.9999, N) # T/J
  Delta_vec  = np.linspace(0.0001, 0.4999, N)
  return [tj_vec, Delta_vec] 

# return [M, x]
def get_ord(tj, Delta, bK, zero=False): # (3.8, 3.10) M not 0 or (3.9), M=0
  bDelta = Delta * tj
  if zero: # (3.9)
    def x_eq(x): # eq. (3.9) M=0
      eq1 = 1-x - 2/(np.exp(bDelta - bK*(1-x)) + 2)
      return eq1
    initial_guess = 0.5
    sol = fsolve(x_eq, initial_guess)
    return [0.0, sol]
  else:
    def M_eq(M): # eq. (3.10) in (3.8) M not 0
      eq1 = M - 2*np.sinh(M/tj)/(np.exp(bDelta - bK*(M/np.tanh(M/tj))) + 2*np.cosh(M/tj))
      return eq1
    initial_guess = 0.1
    solM = fsolve(M_eq, initial_guess)
    solx = 1-solM*1/np.tanh(solM / tj)
  return [solM, solx]


def get_M(tj, x, bK):
    def M_eq(M): # eq. (3.10) M not 0
      eq1 = 1-x - M * 1/np.tanh(M/tj)
      return eq1

    initial_guess = 1
    sol = fsolve(M_eq, initial_guess)
    return sol

# solve (3.7) valid for every M
def get_bDelta(tj, x, bK, M):
  return np.log(2*np.cosh(M/tj) * x/(1-x)) + bK*(1-x)

def get_delta(bDelta, bK, x):
  # FIX: there was also the -bK(1-x) term
  return 1+1/2*np.exp(bDelta-bK)

# betaA...
def get_bA(d, tj):
  return d/2-1/(2*tj) 

def get_bB(d):
  return 1/8*(d**2-d**3/3)

def get_bC(d):
  return 1/6*(1/2*d**3-3/8*d**4+3/40*d**5)

def plot_sign(mat, name="lower.pdf"):
  N = np.shape(mat)[0]
  [tj_vec, x_vec] = get_arrays()
  extent = [x_vec.min(), x_vec.max(), tj_vec.min(), tj_vec.max()]
  mask = np.zeros((N, N))
  mask[mat > 0.0] = 1
  fig, ax = plt.subplots()
  # plt.contour(mask, cmap='hot', interpolation='nearest', extent=extent, levels=200)
  plt.imshow(np.flip(mask, axis=0), cmap='hot', interpolation='nearest', extent=extent)
  plt.scatter(2/3, 1/3, c='red', marker='+')
  plt.xlabel('x')
  plt.ylabel('T/J')
  skip = 20
  plt.xticks(ticks=x_vec[::skip],  labels=[format(x, '.2f') for x in x_vec[::skip]])
  plt.yticks(ticks=tj_vec[::skip], labels=[format(x, '.2f') for x in tj_vec[::skip]])
  plt.colorbar()
  plt.title(name[:-4])
  if False:
    plt.show()
  print("saving", name, "...")
  plt.savefig(name, format="pdf")
  return 0

def plot_contour(mat, name="lower.pdf"):
  N = np.shape(mat)[0]
  [tj_vec, x_vec] = get_arrays()
  extent = [x_vec.min(), x_vec.max(), tj_vec.min(), tj_vec.max()]
  fig, ax = plt.subplots()
  np.clip(mat, -10, 10)
  plt.contour(x_vec, tj_vec, mat, levels=np.arange(0.4, 0.55, 0.05))
  plt.scatter(2/3, 1/3, c='red', marker='+')
  plt.xlabel('x')
  plt.ylabel('T/J')
  skip = 20
  plt.xticks(ticks=x_vec[::skip],  labels=[format(x, '.2f') for x in x_vec[::skip]])
  plt.yticks(ticks=tj_vec[::skip], labels=[format(x, '.2f') for x in tj_vec[::skip]])
  plt.colorbar()
  plt.title(name[:-4])
  if False:
    plt.show()
  print("saving", name, "...")
  plt.savefig(name, format="pdf")
  return 0

def plot_surface(mat, name="surf.pdf", type="normal"):
  # Step 2: Create a grid of x and y values
  N = np.shape(mat)[0]
  if type=="normal":
    [tj_vec, x_vec] = get_arrays()
  else:
    [tj_vec, x_vec] = get_arrays_order()
  
  X, Y = np.meshgrid(tj_vec, x_vec)

  # Step 3: Calculate z values (you can use any function here)
  Z = mat
  # Clip z values to be between -1 and 1
  Z = np.clip(Z, -10, 10)

  # Step 4: Create the 3D surface plot with colormap
  fig = plt.figure()
  ax = fig.add_subplot(111, projection='3d')
  surf = ax.plot_surface(X, Y, Z, cmap='viridis')

  # Add color bar
  fig.colorbar(surf)

  # Set axis labels
  ax.set_xlabel('X-axis')
  ax.set_ylabel('Y-axis')
  ax.set_zlabel('Z-axis')

  # Set plot title
  plt.title(name[:-4])

  # Show the plot
  plt.show()
  return

def compute_orders(
    N=200, 
    K_over_J=0.0,
    num_threads=1,
    reset=True):
  
  print("\n============= defining vectors =============\n")
  [tj_vec, Delta_vec] = get_arrays_order(N=N)
  M      = np.zeros((N, N))
  x      = np.zeros((N, N))
  suffix = '_' + K_over_J.__str__().replace(".", "_")
  if not os.path.isfile('order_M'+suffix+'.npy') or (reset): # check only the first file
    print("\n============= start computing =============\n")
    # Define a worker function to fill the matrices
    def worker(start, end):
        for iD in tqdm(range(start, end)):
            D = Delta_vec[iD]
            for it, tj in enumerate(tj_vec):
                bK = K_over_J * 1 / tj
                [M[it, iD], x[it, iD]] = get_ord(tj, D, bK, zero=True )

    # Calculate the range of indices each thread should handle
    chunk_size = len(Delta_vec) // num_threads
    threads = []

    # Create and start the threads
    for i in range(num_threads):
        start = i * chunk_size
        end = (i + 1) * chunk_size if i < num_threads - 1 else len(Delta_vec)
        thread = threading.Thread(target=worker, args=(start, end))
        threads.append(thread)
        thread.start()

    # Wait for all threads to finish
    for thread in threads:
        thread.join()

    # Save the matrix to the file
    print("\n============= saving =============\n")
    np.save('order_M'+suffix+'.npy', M)
    np.save('order_x'+suffix+'.npy', x)
  else:
    print("\n============= loading =============\n")
    # Load the matrix from the file
    M = np.load('order_M'+suffix+'.npy')
    x = np.load('order_x'+suffix+'.npy')
  return [M, x]

# set ranges and K
# computational range:
def compute_parameters(
    N=200, 
    K_over_J=0.0,
    num_threads=1,
    reset=True):
  
  print("\n============= defining vectors =============\n")
  [tj_vec, x_vec] = get_arrays(N=N)
  M      = np.zeros((N, N))
  bDelta = np.zeros((N, N))
  Delta = np.zeros((N, N))

  bA      = np.zeros((N, N))
  bB      = np.zeros((N, N))
  bC      = np.zeros((N, N))
  suffix = '_' + K_over_J.__str__().replace(".", "_")

  if not os.path.isfile('M_matrix'+suffix+'.npy') or (reset): # check only the first file
    print("\n============= start computing =============\n")
    # Define a worker function to fill the matrices
    def worker(start, end):
        for ix in tqdm(range(start, end)):
            x = x_vec[ix]
            for it, tj in enumerate(tj_vec):
                bK = K_over_J * 1 / tj
                M[it][ix] = get_M(tj, x, bK)
                bDelta[it][ix] = get_bDelta(tj, x, bK, M[it][ix])
                Delta[it][ix] = bDelta[it][ix] * tj

                d = get_delta(bDelta[it][ix], bK, x)
                bA[it][ix] = get_bA(d, tj) * tj
                bB[it][ix] = get_bB(d) * tj
                bC[it][ix] = get_bC(d) * tj

    # Calculate the range of indices each thread should handle
    chunk_size = len(x_vec) // num_threads
    threads = []

    # Create and start the threads
    for i in range(num_threads):
        start = i * chunk_size
        end = (i + 1) * chunk_size if i < num_threads - 1 else len(x_vec)
        thread = threading.Thread(target=worker, args=(start, end))
        threads.append(thread)
        thread.start()

    # Wait for all threads to finish
    for thread in threads:
        thread.join()

    # Save the matrix to the file
    print("\n============= saving =============\n")
    np.save('M_matrix'+suffix+'.npy', M)
    np.save('Delta_matrix'+suffix+'.npy', Delta)
    np.save('bA_matrix'+suffix+'.npy', bA)
    np.save('bB_matrix'+suffix+'.npy', bB)
    np.save('bC_matrix'+suffix+'.npy', bC)

  else:
    print("\n============= loading =============\n")
    # Load the matrix from the file
    M = np.load('M_matrix'+suffix+'.npy')
    Delta = np.load('Delta_matrix'+suffix+'.npy')
    bA = np.load('bA_matrix'+suffix+'.npy')
    bB = np.load('bB_matrix'+suffix+'.npy')
    bC = np.load('bC_matrix'+suffix+'.npy')
  return [M, Delta, bA, bB, bC]



def plot_all(matrices, K_over_J=0.0):
  suffix = '_' + K_over_J.__str__().replace(".", "_")
  [M, Delta, bA, bB, bC] = matrices
  print("\n============= plotting =============\n")
  
  # M and Delta as for MF EQUATIONS
  deltozzo = bB**2-4*bA*bC
  plot_sign(deltozzo, name="first_order_transition"+suffix+".pdf")
  plot_sign(M, name="M"+suffix+".pdf")
  plot_contour(Delta, name="Delta"+suffix+".pdf")
  plot_surface(M, name="M_surface"+suffix+".pdf")
  plot_surface(deltozzo, name="discrim_surface"+suffix+".pdf")
  # plot_surface(M, name="M"+suffix+".pdf")
  # plot_sign(Delta, name="Delta"+suffix+".pdf")
  # plot_surface(Delta, name="Delta_surface"+suffix+".pdf")

  # EXPANSION COEFFICIENTS 
  # plot_sign(bA, name="bA"+suffix+".pdf")
  # print("\n\tmaximum of bC", np.max(bC), "\n\tminimum of bC", np.min(bC))
  # plot_sign(bC, name="bC"+suffix+".pdf")
  return


def plot_implicit(fn, bbox=(-2.5,2.5)):
    ''' create a plot of an implicit function
    fn  ...implicit function (plot where fn==0)
    bbox ..the x,y,and z limits of plotted interval'''
    xmin, xmax, ymin, ymax, zmin, zmax = bbox*3
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    A = np.linspace(xmin, xmax, 100) # resolution of the contour
    B = np.linspace(xmin, xmax, 15) # number of slices
    A1,A2 = np.meshgrid(A,A) # grid on which the contour is plotted

    for z in B: # plot contours in the XY plane
        X,Y = A1,A2
        Z = fn(X,Y,z)
        cset = ax.contour(X, Y, Z+z, [z], zdir='z')
        # [z] defines the only level to plot for this contour for this value of z

    for y in B: # plot contours in the XZ plane
        X,Z = A1,A2
        Y = fn(X,y,Z)
        cset = ax.contour(X, Y+y, Z, [y], zdir='y')

    for x in B: # plot contours in the YZ plane
        Y,Z = A1,A2
        X = fn(x,Y,Z)
        cset = ax.contour(X+x, Y, Z, [x], zdir='x')

    # must set plot limits because the contour will likely extend
    # way beyond the displayed level.  Otherwise matplotlib extends the plot limits
    # to encompass all values in the contour.
    ax.set_zlim3d(zmin,zmax)
    ax.set_xlim3d(xmin,xmax)
    ax.set_ylim3d(ymin,ymax)

    plt.show()

K_over_J_list = [0.0]
for K_over_J in K_over_J_list:
  print("\n°°° computing for K/J =", K_over_J, " °°°\n")
  # matrices = compute_parameters(K_over_J = K_over_J, reset=True)
  # plot_all(matrices, K_over_J=K_over_J)
  orders = compute_orders(K_over_J = K_over_J, reset=True)
  plot_surface(orders[0], name="M_surface.pdf", type="orders")
  plot_surface(orders[1], name="x_surface.pdf", type="orders")