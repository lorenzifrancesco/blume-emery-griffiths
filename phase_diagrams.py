# -*- coding: utf-8 -*-
"""HW1_plot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kruBiiWTGhLCYzhrKc18w39pq7eii685
"""

import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import root
from tqdm import tqdm
import os.path
from mpl_toolkits.mplot3d import Axes3D
import threading
import matplotlib.colors as mcolors

# WARN: since Colab cannot find the LaTeX library, in the plot preparation phase
# it is better to have the script in local and uncomment the following lines for
# have LaTeX fonts
#
plt.rcParams.update({
    "text.usetex": True,
    "font.family": "Helvetica"
})
#
# reproduce figures with the (T/j, x) plane and different K
# bSomething means \beta * Something
#
# solve (3.10) always valid in the assumption M!=0

print("\n============= defining functions =============\n")
def get_arrays(N=200):
  tj_vec = np.linspace(0.11, 0.99, N) # T/J
  x_vec  = np.linspace(0.11, 0.99, N)
  return [tj_vec, x_vec] 

def get_arrays_order(N=200):
  tj_vec = np.linspace(0.0001, 0.9999, N) # T/J
  Delta_vec  = np.linspace(0.0, 0.6, N)
  return [tj_vec, Delta_vec] 

def get_delta(bDelta, bK, x):
  # FIX: there was also the -bK(1-x) term
  return 1+1/2*np.exp(bDelta-bK)

# betaA...
def get_bA(d, tj):
  return d/2-1/(2*tj) 

def get_bB(d):
  return 1/8*(d**2-d**3/3)

def get_bC(d):
  return 1/6*(1/2*d**3-3/8*d**4+3/40*d**5)

def get_M_Delta(tj, x, bK, prev):
  def eqs(pars):
    M, Delta = pars
    return [
      1-x - 2*np.cosh(M/tj)/(np.exp(Delta/tj - bK*(1-x)) +2*np.cosh(M/tj)),
      M - 2*np.sinh(M/tj)/(np.exp(Delta/tj - bK*(1-x)) +2*np.cosh(M/tj)),
    ] 
  initial_guesses = prev
  root_solution = root(eqs, initial_guesses)
  if not root_solution.success:
    # print("WARNING: root finding failed!")
    # print(root_solution.message)
    pass
  sol = root_solution.x
  # print("Solved! results are M =", sol[0], "and Delta =", sol[1])
  return sol


def get_M_Delta_separate(tj, x, bK, prev):
  def eqs(M):
    return 1-x-M/np.tanh(M/tj),
  initial_guesses = prev[0]
  root_solution = root(eqs, initial_guesses)
  if not root_solution.success:
    # print("WARNING: root finding failed!")
    # print(root_solution.message)
    pass
  M = root_solution.x
  def eqs(Delta):
    return 1-x - 2*np.cosh(M/tj)/(np.exp(Delta/tj - bK*(1-x)) +2*np.cosh(M/tj)),
  # print("Solved! results are M =", sol[0], "and Delta =", sol[1])
  initial_guesses = prev[1]
  root_solution = root(eqs, initial_guesses)
  if not root_solution.success:
    # print("WARNING: root finding failed!")
    # print(root_solution.message)
    pass
  Delta = root_solution.x
  return [M, Delta]

def get_M_x(tj, Delta, bK, prev):
  def eqs(pars):
    M, x = pars
    return [
      1-x - 2*np.cosh(M/tj)/(np.exp(Delta/tj - bK*(1-x)) +2*np.cosh(M/tj)),
      M - 2*np.sinh(M/tj)/(np.exp(Delta/tj - bK*(1-x)) +2*np.cosh(M/tj)),
    ] 
  initial_guesses = prev 
  root_solution = root(eqs, initial_guesses)

  if not root_solution.success:
    print("WARNING: root finding failed!")
    print(root_solution.message)
  sol = root_solution.x
  # print("Solved! results are M =", sol[0], "and Delta =", sol[1])
  return sol

def plot_sign(mat, name="lower.pdf"):
  N = np.shape(mat)[0]
  [tj_vec, x_vec] = get_arrays()
  extent = [x_vec.min(), x_vec.max(), tj_vec.min(), tj_vec.max()]
  mask = np.zeros((N, N))
  mask[mat > 0.0] = 1
  fig, ax = plt.subplots()
  # plt.contour(mask, cmap='hot', interpolation='nearest', extent=extent, levels=200)
  plt.imshow(np.flip(mask, axis=0), cmap='hot', interpolation='nearest', extent=extent)
  plt.scatter(2/3, 1/3, c='red', marker='+')
  plt.xlabel('x')
  plt.ylabel('T/J')
  skip = 20
  plt.xticks(ticks=x_vec[::skip],  labels=[format(x, '.2f') for x in x_vec[::skip]])
  plt.yticks(ticks=tj_vec[::skip], labels=[format(x, '.2f') for x in tj_vec[::skip]])
  plt.colorbar()
  plt.title(name[:-4])
  if False:
    plt.show()
  print("saving", name, "...")
  plt.savefig(name, format="pdf")
  return 0

def plot_heatmap(mat, name="lower.pdf", type="normal"):
  N = np.shape(mat)[0]
  if type=="normal":
    [tj_vec, x_vec] = get_arrays()
  else:
    [tj_vec, x_vec] = get_arrays_order()
  extent = [x_vec.min(), x_vec.max(), tj_vec.min(), tj_vec.max()]
  fig, ax = plt.subplots()
  mat = np.clip(mat, -1, 1)
  plt.imshow(np.flip(mat, axis = 0), extent = extent, cmap='hot', interpolation='nearest', vmin=np.min(mat), vmax=np.max(mat))
  plt.colorbar()
  plt.contour(x_vec, tj_vec, mat, colors='cyan',  levels=[0])

  plt.scatter(2/3, 1/3, c='mediumseagreen', marker='+', s=150)
  plt.xlabel('x')
  plt.ylabel('T/J')
  skip = 20
  plt.xticks(ticks=x_vec[::skip],  labels=[format(x, '.2f') for x in x_vec[::skip]])
  plt.yticks(ticks=tj_vec[::skip], labels=[format(x, '.2f') for x in tj_vec[::skip]])
  plt.title(name[:-4])
  if False:
    plt.show()
  print("saving", name, "...")
  plt.savefig(name, format="pdf")
  return 0

def plot_contour(mat, name="lower.pdf", type="normal"):
  N = np.shape(mat)[0]
  if type=="normal":
    [tj_vec, x_vec] = get_arrays()
  else:
    [tj_vec, x_vec] = get_arrays_order()
  extent = [x_vec.min(), x_vec.max(), tj_vec.min(), tj_vec.max()]
  fig, ax = plt.subplots()
  np.clip(mat, -10, 10)
  plt.contour(x_vec, tj_vec, mat, levels=200)
  plt.scatter(2/3, 1/3, c='red', marker='+')
  plt.xlabel('x')
  plt.ylabel('T/J')
  skip = 20
  plt.xticks(ticks=x_vec[::skip],  labels=[format(x, '.2f') for x in x_vec[::skip]])
  plt.yticks(ticks=tj_vec[::skip], labels=[format(x, '.2f') for x in tj_vec[::skip]])
  plt.colorbar()
  plt.title(name[:-4])
  if False:
    plt.show()
  print("saving", name, "...")
  plt.savefig(name, format="pdf")
  return 0

def plot_surface(mat, name="surf.pdf", type="normal"):
  N = np.shape(mat)[0]
  if type=="normal":
    [tj_vec, x_vec] = get_arrays()
  else:
    [tj_vec, x_vec] = get_arrays_order()
  
  X, Y = np.meshgrid(tj_vec, x_vec)
  Z = mat
  # Clip z values to be between -1 and 1
  Z = np.clip(Z, -10, 10)
  fig = plt.figure()
  ax = fig.add_subplot(111, projection='3d')
  surf = ax.plot_surface(X, Y, Z, cmap='viridis')
  # Add color bar
  fig.colorbar(surf)
  # Set axis labels
  ax.set_xlabel('X-axis')
  ax.set_ylabel('Y-axis')
  ax.set_zlabel('Z-axis')
  # Set plot title
  plt.title(name[:-4])
  # Show the plot
  plt.show()
  return


def compute_orders(
    N=200, 
    K_over_J=0.0,
    num_threads=1,
    reset=True):  
  print("\n============= defining vectors =============\n")
  [tj_vec, Delta_vec] = get_arrays_order(N=N)
  M      = np.ones((N, N))
  x      = np.zeros((N, N))
  suffix = '_' + K_over_J.__str__().replace(".", "_")
  if not os.path.isfile('order_M'+suffix+'.npy') or (reset): # check only the first file
    print("\n============= start computing =============\n")
    # Define a worker function to fill the matrices
    def worker(start, end):
        for iD in tqdm(range(start, end)):
          D = Delta_vec[iD]
          prev = [1, 0.5]
          for it, tj in enumerate(tj_vec):
            bK = K_over_J * 1 / tj
            if it == 0:
               pluss = 0
            start_point = [(2*M[it-1, iD]-M[it-1, iD]), x[it, iD-1]]
            [M[it, iD], x[it, iD]] = get_M_x(tj, D, bK, prev = start_point)
    chunk_size = len(Delta_vec) // num_threads
    threads = []
    for i in range(num_threads):
        start = i * chunk_size
        end = (i + 1) * chunk_size if i < num_threads - 1 else len(Delta_vec)
        thread = threading.Thread(target=worker, args=(start, end))
        threads.append(thread)
        thread.start()
    # Wait for all threads to finish
    for thread in threads:
        thread.join()
    # Save the matrix to the file
    print("\n============= saving =============\n")
    np.save('order_M'+suffix+'.npy', M)
    np.save('order_x'+suffix+'.npy', x)
  else:
    print("\n============= loading =============\n")
    # Load the matrix from the file
    M = np.load('order_M'+suffix+'.npy')
    x = np.load('order_x'+suffix+'.npy')
  return [M, x]


def compute_parameters(
    N=200, 
    K_over_J=0.0,
    num_threads=1,
    reset=True):
  print("\n============= defining vectors =============\n")
  [tj_vec, x_vec] = get_arrays(N=N)
  M      = np.zeros((N, N))
  bDelta = np.zeros((N, N))
  Delta =  np.zeros((N, N))
  #
  bA      = np.zeros((N, N))
  bB      = np.zeros((N, N))
  bC      = np.zeros((N, N))
  suffix = '_' + K_over_J.__str__().replace(".", "_")
  # 
  if not os.path.isfile('M_matrix'+suffix+'.npy') or (reset): # check only the first file
    print("\n============= start computing =============\n")
    # Define a worker function to fill the matrices
    def worker(start, end):
        vertical = False
        if vertical:
          for ix in tqdm(range(start, end)):
            x = x_vec[ix]
            start_point = [0.9*(1-x), 0.6]
            for it, tj in enumerate(tj_vec):
                bK = K_over_J * 1 / tj
                [M[it][ix], Delta[it][ix]] = get_M_Delta_separate(tj, x, bK, prev = start_point)
                start_point = [M[it][ix], Delta[it][ix]]
                bDelta[it][ix] = Delta[it][ix] / tj
                d = get_delta(bDelta[it][ix], bK, x)
                bA[it][ix] = get_bA(d, tj) * tj
                bB[it][ix] = get_bB(d) * tj
                bC[it][ix] = get_bC(d) * tj
        else:
          for it, tj in tqdm(enumerate(tj_vec)):  
            for ix in range(start, end):
              x = x_vec[ix]
              if it == 0 :
                start_point = [(1-x)*1.5, 0.5]
              else:
                start_point = [M[it-1][ix-1], Delta[it-1][ix]]
              bK = K_over_J * 1 / tj
              [M[it][ix], Delta[it][ix]] = get_M_Delta_separate(tj, x, bK, prev = start_point)
              start_point = [M[it][ix], Delta[it][ix]]
              bDelta[it][ix] = Delta[it][ix] / tj
              d = get_delta(bDelta[it][ix], bK, x)
              bA[it][ix] = get_bA(d, tj) * tj
              bB[it][ix] = get_bB(d) * tj
              bC[it][ix] = get_bC(d) * tj
    # Calculate the range of indices each thread should handle
    chunk_size = len(x_vec) // num_threads
    threads = []

    # Create and start the threads
    for i in range(num_threads):
        start = i * chunk_size
        end = (i + 1) * chunk_size if i < num_threads - 1 else len(x_vec)
        thread = threading.Thread(target=worker, args=(start, end))
        threads.append(thread)
        thread.start()

    # Wait for all threads to finish
    for thread in threads:
        thread.join()

    # Save the matrix to the file
    print("\n============= saving =============\n")
    np.save('M_matrix'+suffix+'.npy', M)
    np.save('Delta_matrix'+suffix+'.npy', Delta)
    np.save('bA_matrix'+suffix+'.npy', bA)
    np.save('bB_matrix'+suffix+'.npy', bB)
    np.save('bC_matrix'+suffix+'.npy', bC)

  else:
    print("\n============= loading =============\n")
    # Load the matrix from the file
    M = np.load('M_matrix'+suffix+'.npy')
    Delta = np.load('Delta_matrix'+suffix+'.npy')
    bA = np.load('bA_matrix'+suffix+'.npy')
    bB = np.load('bB_matrix'+suffix+'.npy')
    bC = np.load('bC_matrix'+suffix+'.npy')
  return [M, Delta, bA, bB, bC]



def plot_all(matrices, K_over_J=0.0):
  suffix = '_' + K_over_J.__str__().replace(".", "_")
  [M, Delta, bA, bB, bC] = matrices
  print("\n============= plotting =============\n")
  
  # M and Delta as for MF EQUATIONS
  deltozzo = bB**2-4*bA*bC
  plot_heatmap(bA, name="bA"+suffix+".pdf")
  plot_sign(deltozzo, name="first_PT"+suffix +".pdf")
  plot_heatmap(deltozzo, name="heat_first_PT"+suffix +".pdf")
  plot_heatmap(M, name="M"+suffix+".pdf")
  plot_contour(Delta, name="Delta"+suffix+".pdf")
  # EXPANSION COEFFICIENTS 
  # plot_sign(bA, name="bA"+suffix+".pdf")
  # print("\n\tmaximum of bC", np.max(bC), "\n\tminimum of bC", np.min(bC))
  # plot_sign(bC, name="bC"+suffix+".pdf")
  return


def plot_implicit(fn, bbox=(-2.5,2.5)):
    ''' create a plot of an implicit function
    fn  ...implicit function (plot where fn==0)
    bbox ..the x,y,and z limits of plotted interval'''
    xmin, xmax, ymin, ymax, zmin, zmax = bbox*3
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    A = np.linspace(xmin, xmax, 100) # resolution of the contour
    B = np.linspace(xmin, xmax, 15) # number of slices
    A1,A2 = np.meshgrid(A,A) # grid on which the contour is plotted
    for z in B: # plot contours in the XY plane
        X,Y = A1,A2
        Z = fn(X,Y,z)
        cset = ax.contour(X, Y, Z+z, [z], zdir='z')
        # [z] defines the only level to plot for this contour for this value of z
    for y in B: # plot contours in the XZ plane
        X,Z = A1,A2
        Y = fn(X,y,Z)
        cset = ax.contour(X, Y+y, Z, [y], zdir='y')
    for x in B: # plot contours in the YZ plane
        Y,Z = A1,A2
        X = fn(x,Y,Z)
        cset = ax.contour(X+x, Y, Z, [x], zdir='x')
    ax.set_zlim3d(zmin,zmax)
    ax.set_xlim3d(xmin,xmax)
    ax.set_ylim3d(ymin,ymax)

K_over_J_list = [0.0, 2.88, 3.8]
for K_over_J in K_over_J_list:
  print("\n°°° computing for K/J =", K_over_J, " °°°\n")

  matrices = compute_parameters(K_over_J = K_over_J, reset=True)
  plot_all(matrices, K_over_J=K_over_J)

  # ORDERS
  # orders = compute_orders(K_over_J = K_over_J, reset=True, N=200)
  # plot_surface(orders[0], name="order_M.pdf")
  # plot_contour(orders[0], name="order_M.pdf")
  # plot_contour(orders[1], name="order_x.pdf")